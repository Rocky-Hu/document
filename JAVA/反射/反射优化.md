# Java反射性能差的原因

性能差是相对的，是相对于我们直接调用，直接调用的时候，是静态的(可能有人会问，什么时候静态的，就是实例类型，方法名，参数都是确定的)，编译阶段编译器会做权限，可见性，参数等检验，加载阶段解析的时候，就会方法对应的符号引用转换为地址引用，到我们执行方法调用时，就可以直接新建栈帧进行方法调用了。但是反射调用的过程中，是动态的，在执行的时候才明确下来，所以会存在一些验证以及一些安全机制的考虑，另外就是因为是动态的，所以可能会存在一些JVM无法优化的因素。

# 优化

## 方法一：选择合适的API

选择合适的API主要是在获取反射相关元数据的时候尽量避免使用遍历的方法，例如：

- 获取Field实例：尽量避免频繁使用`Class#getDeclaredFields()`或者`Class#getFields()`，应该根据Field的名称直接调用`Class#getDeclaredField()`或者`Class#getField()`。
- 获取Method实例：尽量避免频繁使用`Class#getDeclaredMethods()`或者`Class#getMethods()`，应该根据Method的名称和参数类型数组调用`Class#getDeclaredMethod()`或者`Class#getMethod()`。
- 获取Constructor实例：尽量避免频繁使用`Class#getDeclaredConstructors()`或者`Class#getConstructors()`，应该根据Constructor参数类型数组调用`Class#getDeclaredConstructor()`或者`Class#getConstructor()`。

其实思路很简单，除非我们想要获取Class的所有Field、Method或者Constructor，否则应该避免使用返回一个集合或者数组的API，这样子能减少遍历或者判断带来的性能损耗。

## 方法二：缓存反射操作相关元数据

使用缓存机制缓存反射操作相关元数据的原因是因为反射操作相关元数据的实时获取是比较耗时的，这里列举几个相对耗时的场景：

- 获取Class实例：`Class#forName()`，此方法可以查看源码，耗时相对其他方法高得多。
- 获取Field实例：`Class#getDeclaredField()`、`Class#getDeclaredFields()`、`Class#getField()`、`Class#getFields()`。
- 获取Method实例：`Class#getDeclaredMethod()`、`Class#getDeclaredMethods()`、`Class#getMethod()`、`Class#getMethods()`。
- 获取Constructor实例：`Class#getDeclaredConstructor()`、`Class#getDeclaredConstructors()`、`Class#getConstructor()`、`Class#getConstructors()`。

## 方法三：[reflectasm](https://github.com/EsotericSoftware/reflectasm)

