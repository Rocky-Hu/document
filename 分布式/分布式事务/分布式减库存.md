# 一、方案调研

## 1.1. 分布式事务解决方案

### 1.1.1. 强一致性分布式事务解决方案

XA

缺点：基于数据库XA事务，2PC中每个阶段都会锁定资源，性能不好，不适合高并发的互联网项目。

### 1.2.2. 最终一致性分布式事务解决方案

#### 1.2.2.1. TCC解决方案

是数据一致性敏感度相对高。

业务侵入性强，需要服务参与者同时提供Try、Confirm和Cancel方法。

#### 1.2.2.2. 可靠消息最终一致性解决方案

##### 基于本地消息表 + 非事务型消息队列

##### 基于事务型消息队列

RocketMQ

#### 1.2.2.3. 最大努力通知型解决方案

跨公司，跨项目组。比如对接支付平台。

# 二、TCC

对2PC的改进，TRY + CONFIRM + CANCEL

# 三、设计

## 3.1. 软状态

库存 -> 预占库存

订单 -> 预创建

## 3.2. 组件

TCC方法 + TC管理器  + TC拦截器 + RM协调器 + 定时任务 + 事务日志

## 3.3. 幂等

try -> 同步

confirm, cancel -> 异步(同步) + 幂等 + 重试

# 4、异常点

## 4.1. 空回滚

try未执行，cancel执行。

(cancel时发现无事务日志，则不做任何操作)。

## 4.2.  防悬挂控制

cancel先执行，try后执行。

悬挂的意思是：Cancel 比 Try 接口先执行，出现的原因是 Try 由于网络拥堵而超时，事务管理器生成回滚，触发 Cancel 接口，而最终又收到了 Try 接口调用，但是 Cancel 比 Try 先到。按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，则此时的 Try 接口不应该执行，否则会产生数据不一致，所以我们在 Cancel 空回滚返回成功之前先记录该条事务 xid或业务主键，标识这条记录已经回滚过，Try 接口先检查这条事务xid或业务主键如果已经标记为回滚成功过，则不执行 Try 的业务操作。





