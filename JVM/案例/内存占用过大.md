# 一、日志分析

## 启动参数

~~~
-Xms2048M -Xmx2048M -XX:MetaspaceSize=216M -XX:MaxMetaspaceSize=512M -verbose:gc -Xloggc:/home/work/logs/applogs/gc.log.%p -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps -XX:+PrintAdaptiveSizePolicy -XX:+DisableExplicitGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/work/logs/applogs/ -XX:+UseG1GC
~~~

## TOP内存监控

~~~
top - 03:52:30 up 29 min,  3 users,  load average: 0.00, 0.01, 0.05
Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  3861252 total,  3126224 free,   452056 used,   282972 buff/cache
KiB Swap:  2097148 total,  2097148 free,        0 used.  3178540 avail Mem

   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
  8310 root      20   0 4267328 263132  13668 S  0.0  6.8   0:10.64 java
~~~

RES: 256.96484M

VIRT：4167.3125M

## JMAP输出的日志

~~~

Attaching to process ID 8310, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.202-b08

using thread-local object allocation.
Garbage-First (G1) GC with 1 thread(s)

Heap Configuration:
   MinHeapFreeRatio         = 40
   MaxHeapFreeRatio         = 70
   MaxHeapSize              = 2147483648 (2048.0MB)
   NewSize                  = 1363144 (1.2999954223632812MB)
   MaxNewSize               = 1287651328 (1228.0MB)
   OldSize                  = 5452592 (5.1999969482421875MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 226492416 (216.0MB)
   CompressedClassSpaceSize = 528482304 (504.0MB)
   MaxMetaspaceSize         = 536870912 (512.0MB)
   G1HeapRegionSize         = 1048576 (1.0MB)

Heap Usage:
G1 Heap:
   regions  = 2048
   capacity = 2147483648 (2048.0MB)
   used     = 54466552 (51.94335174560547MB)
   free     = 2093017096 (1996.0566482543945MB)
   2.536296471953392% used
G1 Young Generation:
Eden Space:
   regions  = 35
   capacity = 102760448 (98.0MB)
   used     = 36700160 (35.0MB)
   free     = 66060288 (63.0MB)
   35.714285714285715% used
Survivor Space:
   regions  = 10
   capacity = 10485760 (10.0MB)
   used     = 10485760 (10.0MB)
   free     = 0 (0.0MB)
   100.0% used
G1 Old Generation:
   regions  = 8
   capacity = 2034237440 (1940.0MB)
   used     = 7280632 (6.943351745605469MB)
   free     = 2026956808 (1933.0566482543945MB)
   0.35790472915492105% used

15053 interned Strings occupying 1362432 bytes.
~~~

堆内存占用：51.94335174560547MB

## GC统计日志

~~~
[root@localhost ~]# jstat -gc 8310 1000 3
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
 0.0   10240.0  0.0   10240.0 100352.0 35840.0  1986560.0    7110.0   39040.0 37015.4 5248.0 4863.3      6    0.360   0      0.000    0.360
 0.0   10240.0  0.0   10240.0 100352.0 35840.0  1986560.0    7110.0   39040.0 37015.4 5248.0 4863.3      6    0.360   0      0.000    0.360
 0.0   10240.0  0.0   10240.0 100352.0 35840.0  1986560.0    7110.0   39040.0 37015.4 5248.0 4863.3      6    0.360   0      0.000    0.360
~~~

EU: 35840KB = 35MB

S1U: 10240.0KB = 10MB

OU：7110.0KB = 6.94336MB

# 二、问题说明

上面有几个问题：

1. 堆最大内存分配为2G，从TOP日志中看到VIRT（虚拟内存）占用远远超过了这个数。
2. 从JMAP和GC统计日志看，堆占用内存为51.94335174560547MB，而TOP日志中看到RES（常驻内存）为256.96484M。

# 三、原因分析

## RES

TOP命令中RES列的描述如下：

~~~
**RES** stands for the esident size, which is an accurate representation of how much actual physical memory a process is consuming. (This also corresponds directly to the **%MEM** column)
~~~

## 堆外内存

参考资料：https://www.baeldung.com/native-memory-tracking-in-jvm

java 8下是指除了Xmx设置的java堆（java 8以下版本还包括MaxPermSize设定的持久代大小）外，java进程使用的其他内存。主要包括：

- DirectByteBuffer分配的内存
- JNI里分配的内存
- 线程栈分配占用的系统内存
- jvm本身运行过程分配的内存
- codeCache
- java 8里还包括metaspace元数据空间。

## 分析

### 堆内存查看

~~~
jmap -heap 进程id 或者 jcmd 进程id GC.heap_info
~~~

### **是否存在大量ARENA区**

https://blog.csdn.net/maokelong95/article/details/51989081

~~~
pmap -x 13930|sort -gr -k2|less
~~~

如果存在大量大小为65536或60000左右的内存区域，则很大可能是ARENA区域占用了太多的内存。

这种情况下，最简单粗暴的办法是在JVM启动参数中增加配置：export MALLOC_ARENA_MAX=1。需要注意的是，上述的数值只能是1，其他大于1的数值经实践证明是无法控制ARENA数量的。

### **非堆内存是否开销过大**

~~~
-XX:NativeMemoryTracking=detail
~~~

~~~
jcmd <pid> VM.native_memory detail
~~~

### **堆外内存是否用量太多**

堆外内存也是比较容易被忽略的一个区域，尤其是网络通信非常频繁的应用，这种应用往往大量使用Java NIO，而NIO为了提高效率，往往会申请很多的堆外内存。确认这个区域用量是否过大，最直接的方法是先查看是否是DirectByteBuffer或者MappedByteBuffer使用了较多的堆外内存。

### 结论

https://cloud.tencent.com/developer/article/1849366

