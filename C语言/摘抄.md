#include <stdio.h>的作用相当于把stdio.h文件中的所有内容都输入该行所在的位置。实际上，这是一种“拷贝-粘贴”的操作。include文件提供了一种方便的途径共享许多程序共有的信息。#include这行代码是一条C预处理器指令（preprocessor directive）。通常，C编译器在编译前会对源代码做一些准备工作，即预处理（preprocessing）。

~~~c
int num;
~~~

这行代码叫作声明（declaration）。

声明把特定标识符与计算机内存中的特定位置联系起来，同时也确定了存储在某位置的信息类型或数据类型。

可以用小写字母、大写字母、数字和下划线（_）来命名。而且，名称的第1个字符必须是字母或下划线，不能是数字。

**函数原型（Function Prototype）：即**函数声明给出了函数名、返回值类型、参数列表（重点是参数类型）等与该函数有关的信息。

> 函数原型也被称为函数声明。

**函数原型的作用**：告诉编译器与该函数有关的信息，让编译器知道函数的存在，以及存在的形式，即使函数暂时没有定义，编译器也知道如何使用它。

使用者往往只关心函数的功能和函数的调用形式，很少关心函数的实现细节，将函数定义放在最后，就是尽量屏蔽不重要的信息，凸显关键的信息。将函数声明放到 main() 的前面，在定义函数时也不用关注它们的调用顺序了，哪个函数先定义，哪个函数后定义，都无所谓了。

而在实际开发中，几千上万行、百万行的代码很常见，将这些代码都放在一个源文件中不仅检索麻烦，而且打开文件慢，所以必须将这些代码分散到多个文件中。对于多个文件的程序，通常是将函数定义放到源文件（`.c`文件）中，将函数的声明放到头文件（`.h`文件）中，使用函数时引入对应的头文件就可以，编译器会在链接阶段找到函数体。

我们在使用 printf()、puts()、scanf() 等函数时引入了 stdio.h 头文件，很多初学者认为 stdio.h 中包含了函数定义（也就是函数体），只要有了头文件就能运行，其实不然，头文件中包含的都是函数声明，而不是函数定义，函数定义都放在了其它的源文件中，这些源文件已经提前编译好了，并以动态链接库或者静态链接库的形式存在，只有头文件没有系统库的话，在链接阶段就会报错，程序根本不能运行。

**告知编译器在程序中需要使用此函数，具体函数的定义在链接阶段查找。**

字长是CPU的主要技术指标之一，指的是CPU一次能并行处理的二进制位数，字长总是8的整数倍，通常PC机的字长为16位（早期），32位，64位。

在C语言中，用单引号括起来的单个字符被称为字符常量（characterconstant）。编译器一发现'A'，就会将其转换成相应的代码值。

C只保证了float类型前6位的精度。

字符串（character string）是一个或多个字符的序列。

~~~c
#define TAXRATE 0.015
~~~

编译程序时，程序中所有的TAXRATE都会被替换成0.015。这一过程被称为编译时替换（compile-time substitution）。在运行程序时，程序中所有的替换均已完成。通常，这样定义的常量也称为明示常量（manifest constant）。

转换（conversion）可能会误导读者认为原始值被替换成转换后的值。实际上，转换说明是翻译说明，%d的意思是“把给定的值翻译成十进制整数文本并打印出来”。

- 如果用scanf()读取基本变量类型的值，在变量名前加上一个&；
- 如果用scanf()把字符串读入字符数组中，不要使用&。

sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型（即，size_t类型）。一些不支持C99和C11的编译器可用%u和%lu代替%zd。

> C99做了进一步调整，新增了%zd转换说明用于printf()显示size_t类型的值。如果系统不支持%zd，可使用%u或%lu代替%zd。

C语言规定，sizeof返回size_t类型的值。这是一个无符号整数类型，但它不是新类型。前面介绍过，size_t是语言定义的标准类型。

类似地，C头文件系统可以使用typedef把size_t作为unsigned int或unsigned long的别名。这样，在使用size_t类型时，编译器会根据不同的系统替换标准类型。

C表达式的一个最重要的特性是，每个表达式都有一个值。

在英文中，argument和parameter经常可以互换使用，但是C99标准规定了：对于actual argument或actual parameter使用术语argument（译为实参）；对于formal argument或formal parameter使用术语parameter（译为形参）。为遵循这一规定，我们可以说形参是变量，实参是函数调用提供的值，实参被赋给相应的形参。

缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是512字节和4096字节。行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。

计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。

操作系统使用的另一种方法是存储文件大小的信息。

无论操作系统实际使用何种方法检测文件结尾，在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF（end of file的缩写）。

**静态存储方式**

所谓静态存储方式是指在程序编译期间分配固定的存储空间的方式。该存储方式通常是在变量定义时就分定存储单元并一直保持不变， 
直至整个程序结束。全局变量，静态变量等就属于此类存储方式。 

































