TCP提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。TCP通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。对任何实现而言，关键之处就是在于超时和重传的策略，即怎样决定超时时间间隔和如何确定重传的频率。

# 1. 定时器

## 1.1. 重传定时器

重传定时器使用于当希望收到另一端的确认。

## 1.2. Persist定时器

persist定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。

## 1.3. 保活（keepalive）定时器

keepalive定时器可检测到一个空闲连接的另一端何时崩溃或重启。

## 1.4. 2MSL定时器

2MSL定时器测量一个连接处于TIME_WAIT状态的时间。

# 2. RTT和RTO

- RTT（Round Trip Time）：往返时延，也就是**数据包从发出去到收到对应 ACK 的时间。**RTT 是针对连接的，每一个连接都有各自独立的 RTT。
- RTO（Retransmission Time Out）：重传超时，也就是前面说的超时时间。

# 3. 重传——TCP的重要事件

## 3.1. 基于计时器的重传

这种机制下，**每个数据包都有相应的计时器**，一旦超过 RTO 而没有收到 ACK，就重发该数据包。没收到 ACK 的数据包都会存在重传缓冲区里，等到 ACK 后，就从缓冲区里删除。

首先明确一点，对 TCP 来说，超时重传是**相当重要**的事件（RTO 往往大于两倍的 RTT，超时往往意味着拥塞），一旦发生这种情况，**TCP 不仅会重传对应数据段，还会降低当前的数据发送速率**，因为TCP 会认为当前网络发生了拥塞。

## 3.2. 快速重传

快速重传机制「[RFC5681](https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc5681%23page-11)」基于接收端的反馈信息来引发重传，而非重传计时器超时。

刚刚提到过，基于计时器的重传往往要等待很长时间，而快速重传使用了很巧妙的方法来解决这个问题：**服务器如果收到乱序的包，也给客户端回复 ACK**，只不过是重复的 ACK。就拿刚刚的例子来说，收到乱序的包 6,7,8,9 时，服务器全都发 ACK = 5。这样，客户端就知道 5 发生了空缺。一般来说，如果客户端连续三次收到重复的 ACK，就会重传对应包，而不需要等到计时器超时。

## 3.3. 带选择确认的重传

改进的方法就是 SACK（Selective Acknowledgment），简单来讲就是在快速重传的基础上，**返回最近收到的报文段的序列号范围**，这样客户端就知道，哪些数据包已经到达服务器了。

























































