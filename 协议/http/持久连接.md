初始化了对某服务器HTTP请求的应用程序和可能会在不久的将来对那台服务器发起更多的请求，这种性质被称为站点本地性（site locality）。

因此，HTTP/1.1（以及HTTP/1.0的各种增强版本）允许HTTP设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接。在事务处理结束之后仍然保持在打开状态的TCP连接被称为持久连接。非持久连接会在每个事务结束之后关闭。持久连接会在不同事务时间保持打开状态，直到客户端或服务器决定将其关闭为止。

~~~http
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
~~~

#### HTTP 为什么要做 KeepAlive

- HTTP 虽然是基于有连接状态的 TCP，但本身却是一个无连接状态的协议，客户端建立连接，发出请求，获取响应，关闭连接，然后整个流程就结束了；当有新的 HTTP 请求，则使用新建立的 TCP 连接。老的连接一般会被客户端浏览器或服务器关闭，此时由于是两端主动发的 `FIN` 报文，因此即使 TCP 已经设置了 KeepAlive，TCP 连接也会被正常关闭
- 这种模式下每个 HTTP 请求都会经过三次握手创建新的 TCP，再加上 TCP 慢启动的影响，以及单个网页里包含越来越多的资源请求，因此效果并不理想。为了提升性能，HTTP 规范也提出了 KeepAlive 机制，HTTP 请求携带头部 `Connection: Keep-Alive` 信息，告知服务器不要关闭该 TCP 连接，当服务器收到该请求，完成响应后，不会主动主动关闭该 TCP 连接。而浏览器当然也不会主动关闭，而是在后续请求里复用该 TCP 连接来发送下一个 HTTP 请求
- HTTP1.0 默认不开启 KeepAlive，因此要使用的话需要浏览器支持，在发送 HTTP 请求时主动携带 

`Connection: Keep-Alive``头部，应用服务器同样也要支持；而HTTP1.1规范明确规定了要默认开启KeepAlive，所以支持HTTP1.1的浏览器不需要显式指定，发送请求时会自动携带该头部，只有在想关闭时可以通过设置 ``Connection: Close` 头部告知对端

- 另外，HTTP 的 KeepAlive 机制还提供了头部 `Keep-Alive: max=5, timeout=120` 来控制连接关闭时间，比如如上头部就表示该 TCP 连接还会保持 120 秒，max 表示可以发送的请求数，不过在非管道连接下会被忽略，我们基本都是非管道连接，因此可以忽略
- HTTP/2 为每个域名使用单个 TCP 连接，本身就是连接复用，因此请求不再需要携带头部来开启 KeepAlive



