由于缓存和数据库是分开的，无法做到原子性的同时进行数据修改，可能出现缓存更新失败，或者数据库更新失败的情况，这时候就会出现数据不一致，影响前端业务

- 先更新数据库，再更新缓存。缓存可能更新失败，读到老数据
- 先删除缓存，在更新数据库。并发时，读操作可能还是会将旧数据读回缓存（写还没来得及提交）
- 先更新数据库，再删除缓存。也存在缓存删除失败的可能

> 最经典的缓存+数据库读写的模式，Cache Aside Pattern
>
> 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应
>
> 更新的时候，先更新数据库，然后再删除缓存

为什么是删除而不是更新？

删除更加轻量，延迟加载的一种实现，更新可能涉及多个表，比较耗时

延时双删：先删除缓存，再更新数据库，休眠1s，再次删除缓存。写数据的休眠时间则再读数据业务逻辑的耗时基础上，加上几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据，并发还是可能读到就只覆盖缓存。

# Design Patterns: Cache-Aside Pattern

https://blog.cdemi.io/design-patterns-cache-aside-pattern/























