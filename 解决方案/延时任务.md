# 场景

订单超时关闭、员工二维码超时删除。

有了场景，我们首先来分析一下需求：

1. 延时时间是不固定的，比如我们无法预测用户订未来多久的机票，所以我们不能仅仅提供几种不同延时单位的延时功能。
2. 延时时间精确在秒这个级别就可以了，不需要精确到1秒以内。
3. 最大的延时时间应该有个度。比如最大延时1年或2年(可能有同学问难道不能提供任意最大延时时间么？任意最大延时时间会增加系统的实现的复杂度，而在实际中并没有什么用处，一般我们都尽量不推荐延时太久的消息，因为系统在不断地演变，比如当前设计的时候消息是延时两年，但是两年后系统早已大变样了，两年前的消息都不一定有人记得，更别人说兼容两年前的消息格式了)。

# 解决方案

## 方案一: 定时轮询

1. 时效性差；
2. 效率低

## 方案二: 被动取消

操作时检查是否失效。适不适合具体看使用场景。

## 方案三:延时消息

RocketMQ

## 方案四:延时队列

jdk: DelayQueue

优点:效率高,任务触发时间延迟低。
缺点:(1)服务器重启后，数据全部消失，怕宕机
     (2)集群扩展相当麻烦
     (3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常
     (4)代码复杂度较高

## 方案五:时间轮

https://www.cnblogs.com/luozhiyun/p/12075326.html

https://spongecaptain.cool/post/widget/timingwheel/

https://juejin.cn/post/6844904110399946766

https://blog.acolyer.org/2015/11/23/hashed-and-hierarchical-timing-wheels/

Netty: HashedWheelTimer

Kafka: 层级时间轮TimingWheel

