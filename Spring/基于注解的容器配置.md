# 一、类路径扫描和托管组件

## 1.1. 类路径扫描

使用XML的配置方式，bean定义的配置如下：

~~~
<bean id="firstBean" class="xxx.xxx.xx.SecondBean" />
~~~

XML配置方式，bean定义通过读取xml文件，然后进行解析注册。而基于Annotation方式，可以这样书写bean定义：

~~~java
@Component
public class MyBean {
}
~~~

使用了@Component注解来标记这个类就是一个bean定义类，创建该类型的对象然后交于Spring托管。也就是说不再想通过xml配置的方式来定义bean。达到这样的需求的下一步就是需要告知Spring通过扫描类路径的方式，识别出有此标记的类，然后创建bean定义，注册到容器中。达到这个需求需要配置类路径扫描。xml配置的方式如下：

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="org.framework.learning.spring.scan" />

</beans>
~~~

在xml中使用了<context:component-scan/>标签来告知Spring进行类路径扫描。

### 1.1.1. <context:component-scan/>标签

这个注解的说明如下：

~~~text
Scans the classpath for annotated components that will be auto-registered as Spring beans. By default, the Spring-provided @Component, @Repository, @Service, @Controller, @RestController, @ControllerAdvice, and @Configuration stereotypes will be detected.

Note: This tag implies the effects of the 'annotation-config' tag, activating @Required, @Autowired, @PostConstruct, @PreDestroy, @Resource, @PersistenceContext and @PersistenceUnit annotations in the component classes, which is usually desired for autodetected components (without external configuration). Turn off the 'annotation-config' attribute to deactivate this default behavior, for example in order to use custom BeanPostProcessor definitions for handling those annotations.
~~~

context命名空间的处理类是：org.springframework.context.config.ContextNamespaceHandler。component-scan标签的解析类是：org.springframework.context.annotation.ComponentScanBeanDefinitionParser。

### 1.1.2. 识别候选者

测试示例文件目录：

~~~java
所在包：org.framework.learning.spring.scan;

@Component
public class MyBean {
}

public class MyBean1 {
}

public class MyBeanTest {

    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring-scan.xml");
    }

}
~~~

上面三个类在同一个包下面，只有一个类标记为了@Component。

执行流程描述：

~~~text
org.springframework.context.annotation.ComponentScanBeanDefinitionParser#parse
->
org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan
->
org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents
->
org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents

	->-> 方法内执行：Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
		packageSearchPath：classpath*:org/framework/learning/spring/scan/**/*.class
		表示寻找这个类目录下的所有class类。

		查询出的结果如下：
	1. file [E:\github\framework-learning\flearningspring\target\classes\org\framework\learning\spring\scan\MyBean.class]
	2. file [E:\github\framework-learning\flearning-spring\target\classes\org\framework\learning\spring\scan\MyBean1.class]
	3. file [E:\github\framework-learning\flearning-spring\target\classes\org\framework\learning\spring\scan\MyBeanTest.class]
	
		这里Resource的具体类型是：FileSystemResource。
	
		可以看出每个类文件都当做一个Resource。
	
	->-> 循环处理resources
		第一步：读取Resource所代表的这个类的元数据信息（包括类上的注解、被注解的方法）；
		第二部：使用TypeFilter来判断当前类是否是候选者：默认具体的TypeFilter是AnnotationTypeFilter，annotation类型是interface org.springframework.stereotype.Component。
			这样标有@Component注解的类会被识别为候选者。

->
将识别出的候选者包装为bean definition注册到Spring容器中。
~~~

### 1.1.3. 注册Annotation Config Processor

1.1.2小结分析已经将有@Component标记的候选者识别出，并将bean definition注册到Spring容器中。扫描过程的下一步是：

~~~
org.springframework.context.annotation.ComponentScanBeanDefinitionParser#registerComponents
~~~

这个方法的主要逻辑是：判断<context:component-scan/>标签的属性是否为true，若为true，则执行：

~~~java
AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source);
~~~

<context:component-scan/>的annotation-config属性默认值为true。描述如下：

~~~
Indicates whether the implicit annotation post-processors should be enabled. Default is "true".
~~~

registerAnnotationConfigProcessors方法的作用是注册一系列的Bean Post Processor。可能会注册的Bean Post Processor以及作用如下：

| 类                                     | 作用                                                         |
| :------------------------------------- | :----------------------------------------------------------- |
| ConfigurationClassPostProcessor        | BeanFactoryPostProcessor，处理@Configuration注解             |
| AutowiredAnnotationBeanPostProcessor   | BeanPostProcessor，处理基于注解的自动装配（@Autowired、@Inject、@Value） |
| CommonAnnotationBeanPostProcessor      | BeanPostProcessor，处理JSR-250注解，也就是javax.annotation包下的注解：@Resource、@PostConstruct、@PreDestroy等。 |
| PersistenceAnnotationBeanPostProcessor | JPA support                                                  |
| EventListenerMethodProcessor           | BeanFactoryPostProcessor，处理@EventListener注解             |
| DefaultEventListenerFactory            | EventListenerFactory，处理@EventListener注解                 |







