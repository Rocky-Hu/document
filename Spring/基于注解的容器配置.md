# 一、类路径扫描和托管组件

## 1.1. 类路径扫描 - <context:component-scan />

使用XML的配置方式，bean定义的配置如下：

~~~
<bean id="firstBean" class="xxx.xxx.xx.SecondBean" />
~~~

XML配置方式，bean定义通过读取xml文件，然后进行解析注册。而基于Annotation方式，可以这样书写bean定义：

~~~java
@Component
public class MyBean {
}
~~~

使用了@Component注解来标记这个类就是一个bean定义类，创建该类型的对象然后交于Spring托管。也就是说不再想通过xml配置的方式来定义bean。达到这样的需求的下一步就是需要告知Spring通过扫描类路径的方式，识别出有此标记的类，然后创建bean定义，注册到容器中。达到这个需求需要配置类路径扫描。xml配置的方式如下：

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="org.framework.learning.spring.scan" />

</beans>
~~~

在xml中使用了<context:component-scan/>标签来告知Spring进行类路径扫描。

### 1.1.1. <context:component-scan/>标签

这个注解的说明如下：

~~~text
Scans the classpath for annotated components that will be auto-registered as Spring beans. By default, the Spring-provided @Component, @Repository, @Service, @Controller, @RestController, @ControllerAdvice, and @Configuration stereotypes will be detected.

Note: This tag implies the effects of the 'annotation-config' tag, activating @Required, @Autowired, @PostConstruct, @PreDestroy, @Resource, @PersistenceContext and @PersistenceUnit annotations in the component classes, which is usually desired for autodetected components (without external configuration). Turn off the 'annotation-config' attribute to deactivate this default behavior, for example in order to use custom BeanPostProcessor definitions for handling those annotations.
~~~

context命名空间的处理类是：org.springframework.context.config.ContextNamespaceHandler。component-scan标签的解析类是：org.springframework.context.annotation.ComponentScanBeanDefinitionParser。

### 1.1.2. 识别候选者

测试示例文件目录：

~~~java
所在包：org.framework.learning.spring.scan;

@Component
public class MyBean {
}

public class MyBean1 {
}

public class MyBeanTest {

    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring-scan.xml");
    }

}
~~~

上面三个类在同一个包下面，只有一个类标记为了@Component。

执行流程描述：

~~~text
org.springframework.context.annotation.ComponentScanBeanDefinitionParser#parse
->
org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan
->
org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents
->
org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents

	->-> 方法内执行：Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
		packageSearchPath：classpath*:org/framework/learning/spring/scan/**/*.class
		表示寻找这个类目录下的所有class类。

		查询出的结果如下：
	1. file [E:\github\framework-learning\flearningspring\target\classes\org\framework\learning\spring\scan\MyBean.class]
	2. file [E:\github\framework-learning\flearning-spring\target\classes\org\framework\learning\spring\scan\MyBean1.class]
	3. file [E:\github\framework-learning\flearning-spring\target\classes\org\framework\learning\spring\scan\MyBeanTest.class]
	
		这里Resource的具体类型是：FileSystemResource。
	
		可以看出每个类文件都当做一个Resource。
	
	->-> 循环处理resources
		第一步：读取Resource所代表的这个类的元数据信息（包括类上的注解、被注解的方法）；
		第二部：使用TypeFilter来判断当前类是否是候选者：默认具体的TypeFilter是AnnotationTypeFilter，annotation类型是interface org.springframework.stereotype.Component。
			这样标有@Component注解的类会被识别为候选者。

->
将识别出的候选者包装为bean definition注册到Spring容器中。
~~~

### 1.1.3. 注册Annotation Config Processor

1.1.2小结分析已经将有@Component标记的候选者识别出，并将bean definition注册到Spring容器中。扫描过程的下一步是：

~~~
org.springframework.context.annotation.ComponentScanBeanDefinitionParser#registerComponents
~~~

这个方法的主要逻辑是：判断<context:component-scan/>标签的annotation-config属性是否为true（默认为true），若为true，则执行：

~~~java
AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source);
~~~

<context:component-scan/>的annotation-config属性默认值为true。描述如下：

~~~
Indicates whether the implicit annotation post-processors should be enabled. Default is "true".
~~~

registerAnnotationConfigProcessors方法的作用是注册一系列的Bean Post Processor。可能会注册的Bean Post Processor以及作用如下：

| 类                                     | 作用                                                         |
| :------------------------------------- | :----------------------------------------------------------- |
| ConfigurationClassPostProcessor        | BeanFactoryPostProcessor，处理@Configuration注解             |
| AutowiredAnnotationBeanPostProcessor   | BeanPostProcessor，处理基于注解的自动装配（@Autowired、@Inject、@Value） |
| CommonAnnotationBeanPostProcessor      | BeanPostProcessor，处理JSR-250注解，也就是javax.annotation包下的注解：@Resource、@PostConstruct、@PreDestroy等。 |
| PersistenceAnnotationBeanPostProcessor | JPA support                                                  |
| EventListenerMethodProcessor           | BeanFactoryPostProcessor，处理@EventListener注解             |
| DefaultEventListenerFactory            | EventListenerFactory，处理@EventListener注解                 |

## 1.2. 类路径扫描 - @ComponentScan

可以通过注解的方式来对类路径进行扫描，等同于使用<context:component-scan/>标签，在@Configuration类上加上@ComponentScan注解，指定扫描的根包。

~~~java
@Component
public class MyBean {
}

@Configuration
@ComponentScan(basePackages = "org.framework.learning.spring.scan")
public class MyConfig {
}
~~~

如果未指定扫描的包，那么就会从@ComponentScan所注解的类所在的包开始扫描。

xml配置方式，类路径候选bean的扫描是通过ClassPathBeanDefinitionScanner来完成的。使用@ComponentScan注解的方式，那么能猜测到应该也会有一个扫描类来对指定的包路径下的类进行扫描。处理的入口从@Configuration注解开始。而从1.1中分析，@Configuration注解是通过ConfigurationClassPostProcessor处理的。xml配置方式，使用<context:component-scan/>，有个annotation-config属性，默认值为true，只要为true，就会默认注册上面表格中一些列的组件，当然包括ConfigurationClassPostProcessor。而@ComponentScan注解等同于<context:component-scan/>，不过却未发现这个属性，那么上面表格中一系列的组件是怎么注册的呢？

@ComponentScan描述中有这样的一段话：

> Note that the {@code <context:component-scan>} element has an {@code annotation-config} attribute; however, this annotation does not. This is because in almost all cases when using {@code @ComponentScan}, default annotation config processing (e.g. processing {@code @Autowired} and friends) is assumed. Furthermore, when using {@link AnnotationConfigApplicationContext}, annotation config processors are always registered, meaning that any attempt to disable them at the {@code @ComponentScan} level would be ignored.

意思就是当我们使用AnnotationConfigApplicationContext，那么annotation config processors是会自动注册的。

自动注册流程：

~~~java
org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext(java.lang.Class<?>...)
->
org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()
public AnnotationConfigApplicationContext() {
		this.reader = new AnnotatedBeanDefinitionReader(this);
		this.scanner = new ClassPathBeanDefinitionScanner(this);
}
->
org.springframework.context.annotation.AnnotatedBeanDefinitionReader#AnnotatedBeanDefinitionReader(org.springframework.beans.factory.support.BeanDefinitionRegistry)
->
org.springframework.context.annotation.AnnotatedBeanDefinitionReader#AnnotatedBeanDefinitionReader(org.springframework.beans.factory.support.BeanDefinitionRegistry, org.springframework.core.env.Environment)
->
public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
		Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
		Assert.notNull(environment, "Environment must not be null");
		this.registry = registry;
		this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
		AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
}
~~~

看到了熟悉的AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)。实例化AnnotatedBeanDefinitionReader的时候触发annotation config processors的注册。

解析@Configuration注解的ConfigurationClassPostProcessor组件已经找到，现在就是看其处理过程。着重看到就是对@ComponentScan的解析处理。

~~~java
org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry
->
org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions
->
org.springframework.context.annotation.ConfigurationClassParser#parse(java.util.Set<org.springframework.beans.factory.config.BeanDefinitionHolder>)
->
org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass
->
org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass
// Process any @ComponentScan annotations
Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
->
org.springframework.context.annotation.ComponentScanAnnotationParser#parse
ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
				componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);
...
String[] basePackagesArray = componentScan.getStringArray("basePackages");
->
org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan
~~~

可以看到和<context:component-scan/>内部处理一样，最终还是通过ClassPathBeanDefinitionScanner进行类路径扫描，扫描出候选的组件，然后进行注册。

同时扫描出Configuration Class组件后还会继续处理@Configuation注解的类下的@Bean注解。

## 1.3. @Bean

### 1.3.1. 创建模式

#### 1.3.1.1. 实例工厂方法模式

通过工厂方法模式实例化Bean，定义方式如下：

~~~java
public class DefaultServiceLocator {

    public ClientService createClientServiceInstance() {
        return new ClientService();
    }
    
}

<bean id="serviceLocator" class="examples.DefaultServiceLocator"/>

<bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/>
~~~

若@Bean修饰的是普通方法，创建方式就是实例工厂方法模式。

~~~java
@Configuration
public class DefaultServiceLocator {

		@Bean
    public ClientService createClientServiceInstance() {
        return new ClientService();
    }
    
}
~~~

源代码中的处理如下：

~~~java
org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod

// instance @Bean method
beanDef.setFactoryBeanName(configClass.getBeanName());
beanDef.setUniqueFactoryMethodName(methodName);
~~~

#### 1.3.1.2. 静态工厂方法实例化模式

通过静态工厂方法模式实例化Bean，定义方式如下：

~~~java
public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}

<bean id="clientService" class="examples.ClientService" factory-method="createInstance"/>
~~~

若@Bean修饰的方法是静态方法，创建方式就是静态工厂方法模式。

~~~java
@Configuration
public class DefaultServiceLocator {

		@Bean
    public static ClientService createClientServiceInstance() {
        return new ClientService();
    }
    
}
~~~

源码中处理如下：

~~~java
org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod

if (metadata.isStatic()) {
  // static @Bean method
  if (configClass.getMetadata() instanceof StandardAnnotationMetadata) {
    beanDef.setBeanClass(((StandardAnnotationMetadata) configClass.getMetadata()).getIntrospectedClass());
  }
  else {
    beanDef.setBeanClassName(configClass.getMetadata().getClassName());
  }
  beanDef.setUniqueFactoryMethodName(methodName);
}
~~~

### 1.3.2. 内部bean引用

@Configuration注解类下的@Bean方法具备内部引用特性。

~~~java
@Configuration
 public class AppConfig {

     @Bean
     public FooService fooService() {
         return new FooService(fooRepository());
     }

     @Bean
     public FooRepository fooRepository() {
         return new JdbcFooRepository(dataSource());
     }

     // ...
 }
~~~

@Confirguation类的@Bean方法通过CGLIB进行增强，所以AOP特性都是保留的。也就是说类内部的方法引用同样能被AOP拦截。需要被CGLIB增加那么@Bean注解的方法就不能是final或者是private类型。

### 1.3.3. @Bean lite模式

@Bean修饰的方法可以存在于普通的@Component类下。

~~~java
@Component
 public class Calculator {
     public int sum(int a, int b) {
         return a+b;
     }

     @Bean
     public MyBean myBean() {
         return new MyBean();
     }
 }
~~~

这种模式下内部方法调用就是普通的方法调用，不支持内部bean引用，Spring也不会通过CGLIB代理进行拦截。同时方法修饰也没有限制。

### 1.3.3. 引导类型的@Bean

若定义的是BeanFactoryPostProcessor类型的bean，那么@Bean修饰的方法必须是static，因为BeanFactoryPostProcessor要先于其他的Bean实例化，而@Configuration注解的类本身就是一个要实例化的bean，而非static的方法要在它实例化出来之后才能使用。而static方法不需要先创建宿主对象。不定义成static，会出现lifecycle问题。

~~~java
@Bean
public static PropertySourcesPlaceholderConfigurer pspc() {
	// instantiate, configure and return pspc ...
}
~~~

因为是static修饰，所以AOP语义也是不存在的。















