# 一、初识Spring事件处理机制

## 1.1. 使用ApplicationContext发布事件

~~~java
public class MessageEvent extends ApplicationEvent {

    private String message;

    public MessageEvent(Object source, String message) {
        super(source);
        System.out.println("MessageEvent constructor...");
        this.message = message;
    }

    public String getMessage() {
        return message;
    }

    @Override
    public String toString() {
        return "MessageEvent{" +
                "message='" + message + '\'' +
                '}';
    }

}

public class MessageEventListener implements ApplicationListener<MessageEvent> {

    @Override
    public void onApplicationEvent(MessageEvent messageEvent) {
        System.out.println("Message Received : " + messageEvent.getMessage());
    }

}

public class MessageEventTest {

    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring-event.xml");

        context.publishEvent(new MessageEvent(new Object(), "Message 1"));
        context.publishEvent(new MessageEvent(new Object(), "Message 2"));
        context.publishEvent(new MessageEvent(new Object(), "Message 3"));

        ((ClassPathXmlApplicationContext)context).close();
    }

}
~~~

结果如下：

~~~reStructuredText
MessageEvent constructor...
Message Received : Message 1
MessageEvent constructor...
Message Received : Message 2
MessageEvent constructor...
Message Received : Message 3
~~~

## 1.2. 自定义Event Publisher发布事件

~~~java
public class CustomSpringEvent extends ApplicationEvent {

    private String message;

    public CustomSpringEvent(Object source, String message) {
        super(source);
        this.message = message;
    }

    public String getMessage() {
        return message;
    }

}

public class CustomSpringEventListener implements ApplicationListener<CustomSpringEvent> {

    @Override
    public void onApplicationEvent(CustomSpringEvent event) {
        System.out.println("Received spring custom event - " + event.getMessage());
    }

}

public class CustomSpringEventPublisher implements ApplicationEventPublisherAware {

    private ApplicationEventPublisher applicationEventPublisher;

    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        this.applicationEventPublisher = applicationEventPublisher;
    }

    public void doStuffAndPublishAnEvent(final String message) {
        System.out.println("Publishing custom event. ");
        CustomSpringEvent customSpringEvent = new CustomSpringEvent(this, message);
        applicationEventPublisher.publishEvent(customSpringEvent);
        System.out.println("Finish publish custom event.");
    }

}

public class CustomSpringEventTest {

    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring-event.xml");
        CustomSpringEventPublisher customSpringEventPublisher = (CustomSpringEventPublisher) context.getBean("customSpringEventPublisher");
        customSpringEventPublisher.doStuffAndPublishAnEvent("hello");
    }

}
~~~

## 1.3. 事件处理机制的参与角色

Spring中事件通知机制有三个参与者：

- 事件对象（ApplicationEvent）：Event对象，包装事件源及事件信息
- 事件发布器（ApplicationEventPublisherAware）：发布事件
- 事件监听器（ApplicationListener）：监听事件以处理事件

ApplicationContext类实现了ApplicationEventPublisherAware接口，所以1.1中可以直接使用ApplicationContext对象来发布事件。

# 二、深入Spring事件处理机制

## 2.1. 事件异步处理

修改一下1.2的示例，修改后如下：

~~~java
public class CustomSpringEventListener implements ApplicationListener<CustomSpringEvent> {

    @Override
    public void onApplicationEvent(CustomSpringEvent event) {
        try {
            Thread.currentThread().sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Received spring custom event - " + event.getMessage());
    }

}

~~~

修改CustomSpringEventListener，在方法中让当前线成休眠2秒。测试可以发现doStuffAndPublishAnEvent的结束被推迟。

上述处理都是同步事件处理机制，什么意思呢？就是说事件发布器发布消息后要等待所有监听器执行完逻辑才会继续往下执行，也就是说事件发布器被事件监听器阻塞了（两者是被同一个线程处理）。

通常情况下，事件需要进行异步处理，也就是说事件发布器不应该被事件监听器阻塞，其只负责发布事件，不同步等待事件处理结果。

Spring提供了异步处理事件的功能。其内部原理就是使用另外一个线程去处理事件，也就是说发布事件和处理事件不同线程。

> 同步本质上就是同一个线程方法调用。

Spring内部事件的发布是通过ApplicationEventMulticaster接口来完成的，ApplicationEventPublisher是外的使用接口，而内部事件监听器的事件通知是由ApplicationEventMulticaster完成的：

~~~java
getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
~~~

org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)

~~~java
@Override
public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
    Executor executor = getTaskExecutor();
    for (ApplicationListener<?> listener : getApplicationListeners(event, type)) {
        if (executor != null) {
            executor.execute(() -> invokeListener(listener, event));
        }
        else {
            invokeListener(listener, event);
        }
    }
}
~~~

这里看到了熟悉的跟线程池有关的Executor接口，从上面的逻辑可以看出提供了Executor，那么就异步执行，反之就同步执行。

改为异步处理的解决方案：

1. xml配置方式，增加如下配置：

~~~xml
  <bean id="simpleAsyncTaskExecutor" class="org.springframework.core.task.SimpleAsyncTaskExecutor" />
    <bean id="applicationEventMulticaster" class="org.springframework.context.event.SimpleApplicationEventMulticaster">
        <property name="taskExecutor" ref="simpleAsyncTaskExecutor" />
    </bean>

~~~

2. 注解方式，增加如下定义：

~~~java
@Configuration
public class AsynchronousSpringEventsConfig {
    @Bean(name = "applicationEventMulticaster")
    public ApplicationEventMulticaster simpleApplicationEventMulticaster() {
        SimpleApplicationEventMulticaster eventMulticaster =
          new SimpleApplicationEventMulticaster();
        
        eventMulticaster.setTaskExecutor(new SimpleAsyncTaskExecutor());
        return eventMulticaster;
    }
}
~~~

两者本质上都是指定一个具有Executor的ApplicationEventMulticaster。

注意：这里有个要注意，就是自定义的ApplicationEventMulticaster的bean名称必须是"applicationEventMulticaster"。因为容器初始化时有这样的判断：

org.springframework.context.support.AbstractApplicationContext#initApplicationEventMulticaster

~~~java
protected void initApplicationEventMulticaster() {
	ConfigurableListableBeanFactory beanFactory = getBeanFactory();
	if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
		this.applicationEventMulticaster =
				beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
		if (logger.isTraceEnabled()) {
			logger.trace("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]");
		}
	}
	else {
		this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
		beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
		if (logger.isTraceEnabled()) {
			logger.trace("No '" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + "' bean, using " +
					"[" + this.applicationEventMulticaster.getClass().getSimpleName() + "]");
		}
	}
}
~~~

如果容器中不存在名为"applicationEventMulticaster"的bean，则创建一个SimpleApplicationEventMulticaster对象。

## 2.2. Spring内置事件

### 2.2.1. ContextRefreshedEvent（上下文初始化或刷新）

当ApplicationContext初始化（initialized）或者刷新后（refreshed）会发布此事件。

org.springframework.context.support.AbstractApplicationContext#finishRefresh

~~~java
protected void finishRefresh() {
		// Clear context-level resource caches (such as ASM metadata from scanning).
		clearResourceCaches();

		// Initialize lifecycle processor for this context.
		initLifecycleProcessor();

		// Propagate refresh to lifecycle processor first.
		getLifecycleProcessor().onRefresh();

		// Publish the final event.
		publishEvent(new ContextRefreshedEvent(this));

		// Participate in LiveBeansView MBean, if active.
		LiveBeansView.registerApplicationContext(this);
}
~~~

### 2.2.2. ContextClosedEvent（上下文关闭）

当调用ApplicationContext的close()方法时发布此事件。

~~~java
org.springframework.context.support.AbstractApplicationContext#close 
->
org.springframework.context.support.AbstractApplicationContext#doClose
~~~

### 2.2.3. ContextStartedEvent（Lifecyle的start事件）

当调用ApplicationContext的start()方法时发布此事件。

org.springframework.context.support.AbstractApplicationContext#start

~~~java
@Override
public void start() {
	getLifecycleProcessor().start();
	publishEvent(new ContextStartedEvent(this));
}
~~~

### 2.2.4. ContextStoppedEvent（Lifecycle的stop事件）

当调用ApplicationContext的stop()方法时发布此事件。

org.springframework.context.support.AbstractApplicationContext#stop

~~~java
@Override
public void stop() {
    getLifecycleProcessor().stop();
    publishEvent(new ContextStoppedEvent(this));
}
~~~

## 2.3. 注解驱动的EventListener

从Spring4.2开始实现一个监听器不需要强制实现ApplicationListener接口。通过在方法上使用@EventListener注解也能达到监听效果。

API中关于@EventListener的描述：

1. 如果被注解的方法支持单事件类型，那么这个方法可以声明一个表示该事件类型的参数；
2. 如果被注解的方法制成多个事件类型，通过注解的classes属性进行指定；
3. 事件可以使ApplicationEvent的实例或者任意对象；
4. EventListener注解是通过EventListenerMethodProcessor来处理的，当xml中配置了<context:annotation-config/>或者<context:component-scan/>，就会自动注册这个bean；
5. 被注解的方法可以返回结果，这个结果会被作为一个新的事件。如果返回的结果类型是数组或者集合，那么里面的每一个元素会被当成一个新的独立事件；
6. 









