# 一、channelRegistered

对于NioServerSocketChannel，执行链路如下：

~~~java
io.netty.bootstrap.AbstractBootstrap#bind(int)
->
io.netty.bootstrap.AbstractBootstrap#bind(java.net.SocketAddress)
->
io.netty.bootstrap.AbstractBootstrap#doBind
->
io.netty.bootstrap.AbstractBootstrap#initAndRegister
这个方法会创建NioServerSocketChannel的实例，然后注册到boss group中（EventLoopGroup）
ChannelFuture regFuture = config().group().register(channel);
->
io.netty.channel.MultithreadEventLoopGroup#register(io.netty.channel.Channel)
->
io.netty.channel.SingleThreadEventLoop#register(io.netty.channel.Channel)
->
io.netty.channel.SingleThreadEventLoop#register(io.netty.channel.ChannelPromise)
->
io.netty.channel.AbstractChannel.AbstractUnsafe#register
->
io.netty.channel.AbstractChannel.AbstractUnsafe#register0
这个方法内部调用io.netty.channel.nio.AbstractNioChannel#doRegister方法，实际执行的操作就是
selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
这个底层实际上就是完成NIO的ServerSocketChannel的注册，将ServerSocketChannel注册到Selector中。
接下来执行pipeline.fireChannelRegistered();
->
io.netty.channel.DefaultChannelPipeline#fireChannelRegistered
->
io.netty.channel.AbstractChannelHandlerContext#invokeChannelRegistered(io.netty.channel.AbstractChannelHandlerContext)
->
io.netty.channel.AbstractChannelHandlerContext#invokeChannelRegistered()
->
io.netty.channel.DefaultChannelPipeline.HeadContext#channelRegistered
->
io.netty.channel.AbstractChannelHandlerContext#fireChannelRegistered
invokeChannelRegistered(findContextInbound(MASK_CHANNEL_REGISTERED));
->
一系列操作后会调用inboud handler的channelRegistered方法
~~~

可以看到对于NioServerSocketChannel，在ServerBootstrap执行bind的时候，会创建对象，然后注册到boos group中然后就触发了channelRegistered事件。

对于NioSocketChannel，ServerBootstrap在启动的时候，创建了NioServerSocketChannel，同时会初始化这个channel，在初始化这个channel的说话，会往这个channel的pipe line增加一个inboud handler，这个handler是ServerBootstrapAcceptor，其主要的作用就是注册从Selector中获取到的连接包装成的NioSocketChannel。

~~~
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    final Channel child = (Channel) msg;

    child.pipeline().addLast(childHandler);

    setChannelOptions(child, childOptions, logger);
    setAttributes(child, childAttrs);

    try {
        childGroup.register(child).addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (!future.isSuccess()) {
                    forceClose(child, future.cause());
                }
            }
        });
    } catch (Throwable t) {
        forceClose(child, t);
    }
}
~~~

跟上面一下，只要是调用了EventLoop的register方法，在注册成功之后都会触发channelRegistered事件。这个事件就是表示已经将channel注册到了EventLoop中。

# 二、channelActive

## NioServerSocketChannel

继续关注channel注册的逻辑，在io.netty.channel.AbstractChannel.AbstractUnsafe#register0方法中有这样的一段逻辑：

~~~
private void register0(ChannelPromise promise) {
    try {
        pipeline.fireChannelRegistered();
        if (isActive()) {
            if (firstRegistration) {
                pipeline.fireChannelActive();
            } else if (config().isAutoRead()) {
                // This channel was registered before and autoRead() is set. This means we need to begin read
                // again so that we process inbound data.
                //
                // See https://github.com/netty/netty/issues/4805
                beginRead();
            }
        }
    }
}
~~~

channelRegistered()这个就不说了，就是上面的分析，关注一下isActive这个方法，对于NioServerSocketChannel, 方法io.netty.channel.socket.nio.NioServerSocketChannel#isActive的实现如下：

~~~
@Override
public boolean isActive() {
    // As java.nio.ServerSocketChannel.isBound() will continue to return true even after the channel was closed
    // we will also need to check if it is open.
    return isOpen() && javaChannel().socket().isBound();
}

isOpen() 内部执行是java.nio.channels.spi.AbstractInterruptibleChannel#isOpen
javaChannel().socket().isBound() 内部执行是java.net.ServerSocket#isBound

也就是说判断当前channel是否是active的，还是调用的java网络包中的类的方法。

对于ServerSocket，它是用于监听端口，所以判断是否active就是判断是否成功绑定到一个地址。正如isBound方法描述的一样：
true if the ServerSocket successfully bound to an address
~~~

测试发现这里的isActive是false的，这是因为地址的绑定操作还未执行。反正就是channel注册成功，然后底层的ServerSocket成功绑定了地址和端口后，就表明这个channel就是是活跃的了，然后就会触发channelActive事件。

## NioSocketChannel

上面分析的是NioServerSocketChannel，其底层是ServerSocket，是监听socket，其active的判断条件就是判断是否成功绑定地址和端口，简化来说就是下面这段代码：

~~~
ServerSocket serverSocket = serverChannel.socket();
serverSocket.bind(new InetSocketAddress(1234));
~~~

现在来分析NioSocketChannel的激活。

在上面分析注册的时候说过，从Selector中accept出的连接，包装成NioSocketChannel之后，会交于io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor来处理，其处理逻辑如下：

~~~
childGroup.register(child).addListener(new ChannelFutureListener() {
    @Override
    public void operationComplete(ChannelFuture future) throws Exception {
        if (!future.isSuccess()) {
            forceClose(child, future.cause());
        }
    }
});
~~~

这里又到了EventLoop的注册方法。最终执行到的还是io.netty.channel.AbstractChannel.AbstractUnsafe#register0方法：

~~~
private void register0(ChannelPromise promise) {
    try {
        pipeline.fireChannelRegistered();
        if (isActive()) {
            if (firstRegistration) {
                pipeline.fireChannelActive();
            } else if (config().isAutoRead()) {
                // This channel was registered before and autoRead() is set. This means we need to begin read
                // again so that we process inbound data.
                //
                // See https://github.com/netty/netty/issues/4805
                beginRead();
            }
        }
    }
}
~~~

判断NioSocketChannel是否是active就和判断NioServerSocketChannel不同了，NioSocketChannel的isActive的实现如下：

~~~
@Override
public boolean isActive() {
    SocketChannel ch = javaChannel();
    return ch.isOpen() && ch.isConnected();
}
~~~

isConnected()方法代码如下：

~~~
/**
     * Tells whether or not this channel's network socket is connected.
     *
     * @return  <tt>true</tt> if, and only if, this channel's network socket
     *          is {@link #isOpen open} and connected
*/
public abstract boolean isConnected();
~~~

也就是判断tcp连接是否是ESTABLISHED状态。

回到注册的这个方法：

~~~
private void register0(ChannelPromise promise) {
    try {
        pipeline.fireChannelRegistered();
        if (isActive()) {
            if (firstRegistration) {
                pipeline.fireChannelActive();
            } else if (config().isAutoRead()) {
                // This channel was registered before and autoRead() is set. This means we need to begin read
                // again so that we process inbound data.
                //
                // See https://github.com/netty/netty/issues/4805
                beginRead();
            }
        }
    }
}
~~~

在上面我们分析NioServerSocketChannel的时候说到过，注册这个方法里面这个isActive返回是false的，是因为这个时候还没有执行ServerSocket的bind操作，而对于NioSocketChannel，从Selector中获取到连接，然后交于ServerBootstrapAcceptor，然后到这里的注册，可以通过ServerSocketChannel accept出来那么就说明连接是已经就绪了的，那么这里isConnected()就是true的，所以对于NioSocketChannel，这里的isActive返回的就是true，这时候就会进入到if语句中执行 pipeline.fireChannelActive()， 触发channelActive事件。

# 三、channelRead

在Java的网络编程中，ServerSocket是监听socket，Socket是普通的连接Socket，ServerSocket对OP_ACCEPT事件感兴趣，Socket对OP_READ事件感兴趣。

ServerSocket的读就是从TCP的连接就绪队列中获取已连接就绪的TCP连接，而Socket的读就是真正的进行缓冲区数据的读取。而这两个事件是否就绪，是通过Selector的select方法来操作的。在Netty中，其内部原理同样如此。读的统一入口端口是

io.netty.channel.nio.NioEventLoop#processSelectedKey(java.nio.channels.SelectionKey, io.netty.channel.nio.AbstractNioChannel)的这段代码：

~~~java
private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
    if (!k.isValid()) {
        final EventLoop eventLoop;
        try {
            eventLoop = ch.eventLoop();
        } catch (Throwable ignored) {
            // If the channel implementation throws an exception because there is no event loop, we ignore this
            // because we are only trying to determine if ch is registered to this event loop and thus has authority
            // to close ch.
            return;
        }
        // Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop
        // and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is
        // still healthy and should not be closed.
        // See https://github.com/netty/netty/issues/5125
        if (eventLoop == this) {
            // close the channel if the key is not valid anymore
            unsafe.close(unsafe.voidPromise());
        }
        return;
    }

    try {
        int readyOps = k.readyOps();
        // We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise
        // the NIO JDK channel implementation may throw a NotYetConnectedException.
        if ((readyOps & SelectionKey.OP_CONNECT) != 0) {
            // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking
            // See https://github.com/netty/netty/issues/924
            int ops = k.interestOps();
            ops &= ~SelectionKey.OP_CONNECT;
            k.interestOps(ops);

            unsafe.finishConnect();
        }

        // Process OP_WRITE first as we may be able to write some queued buffers and so free memory.
        if ((readyOps & SelectionKey.OP_WRITE) != 0) {
            // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write
            ch.unsafe().forceFlush();
        }

        // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead
        // to a spin loop
        if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
            unsafe.read();
        }
    } catch (CancelledKeyException ignored) {
        unsafe.close(unsafe.voidPromise());
    }
}
~~~

更确切的说，重要的部分是：

~~~
// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead
// to a spin loop
if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
    unsafe.read();
}
~~~

这里看到了熟悉的readOps和OP_READ、OP_ACCEPT。上面我们已经说了对于读来说ServerSocket和Socket的操作是不同的，这里同样如此，NioServerSocketChannel和NioSocketChannel对于read的实现也是不同的，

NioServerSocketChannel的实现如下：

io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe

~~~
private final class NioMessageUnsafe extends AbstractNioUnsafe {

    private final List<Object> readBuf = new ArrayList<Object>();

    @Override
    public void read() {
        assert eventLoop().inEventLoop();
        final ChannelConfig config = config();
        final ChannelPipeline pipeline = pipeline();
        final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();
        allocHandle.reset(config);

        boolean closed = false;
        Throwable exception = null;
        try {
            try {
                do {
                    int localRead = doReadMessages(readBuf);
                    if (localRead == 0) {
                        break;
                    }
                    if (localRead < 0) {
                        closed = true;
                        break;
                    }

                    allocHandle.incMessagesRead(localRead);
                } while (continueReading(allocHandle));
            } catch (Throwable t) {
                exception = t;
            }

            int size = readBuf.size();
            for (int i = 0; i < size; i ++) {
                readPending = false;
                pipeline.fireChannelRead(readBuf.get(i));
            }
            readBuf.clear();
            allocHandle.readComplete();
            pipeline.fireChannelReadComplete();

            if (exception != null) {
                closed = closeOnReadError(exception);

                pipeline.fireExceptionCaught(exception);
            }

            if (closed) {
                inputShutdown = true;
                if (isOpen()) {
                    close(voidPromise());
                }
            }
        } finally {
            // Check if there is a readPending which was not processed yet.
            // This could be for two reasons:
            // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
            // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
            //
            // See https://github.com/netty/netty/issues/2254
            if (!readPending && !config.isAutoRead()) {
                removeReadOp();
            }
        }
    }
}
~~~

此操作的内部就会触发channelRead事件。

NioSocketChannel的实现如下：

io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe

~~~
protected class NioByteUnsafe extends AbstractNioUnsafe { 

    public final void read() {
        final ChannelConfig config = config();
        if (shouldBreakReadReady(config)) {
            clearReadPending();
            return;
        }
        final ChannelPipeline pipeline = pipeline();
        final ByteBufAllocator allocator = config.getAllocator();
        final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();
        allocHandle.reset(config);

        ByteBuf byteBuf = null;
        boolean close = false;
        try {
            do {
                byteBuf = allocHandle.allocate(allocator);
                allocHandle.lastBytesRead(doReadBytes(byteBuf));
                if (allocHandle.lastBytesRead() <= 0) {
                    // nothing was read. release the buffer.
                    byteBuf.release();
                    byteBuf = null;
                    close = allocHandle.lastBytesRead() < 0;
                    if (close) {
                        // There is nothing left to read as we received an EOF.
                        readPending = false;
                    }
                    break;
                }

                allocHandle.incMessagesRead(1);
                readPending = false;
                pipeline.fireChannelRead(byteBuf);
                byteBuf = null;
            } while (allocHandle.continueReading());

            allocHandle.readComplete();
            pipeline.fireChannelReadComplete();

            if (close) {
                closeOnRead(pipeline);
            }
        } catch (Throwable t) {
            handleReadException(pipeline, byteBuf, t, close, allocHandle);
        } finally {
            // Check if there is a readPending which was not processed yet.
            // This could be for two reasons:
            // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
            // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
            //
            // See https://github.com/netty/netty/issues/2254
            if (!readPending && !config.isAutoRead()) {
                removeReadOp();
            }
        }
    }

}
~~~

这里也是会触发fireChannelRead事件。

















